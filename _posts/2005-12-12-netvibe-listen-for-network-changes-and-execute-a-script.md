---
layout: post
title: NetVibe: listen for network changes and execute a script.
date: 2005-12-12 23:10
author: chrispelatari
comments: true
categories: [Uncategorized]
---
<p>A few people asked for the source code/a download for the little widget I<br /> whipped up on Friday, so I spent this morning adding a little bit of<br /> persistence. The original code for switching my networks is still in there (and<br /> still works on my machine if I change the code to point there) but I made it<br /> more general and also used it as an excuse to explore the Settings API as well<br /> as use a couple of neat features of VS 2005. (If you don't care about any of<br /> that stuff and just want to see if you can build the project and make some use<br /> out of it, it can be found <a href="http://projectdistributor.net/Releases/Release.aspx?releaseId=289">here on<br /> projectdistributor</a>. )</p><p>So the settings goop in VS 2005 is pretty neat, but there's a limited subset<br /> (it seems) that you can specify as types in the designer. I wanted to use a<br /> Domain Object, tho - so, no designer love for me. I ended up making a simple<br /> string setting just to see what code it generated for UserScopedSetting<br /> properties. I ended up with this:</p><pre>[global::System.Configuration.UserScopedSetting]
<span style="color:blue;">public</span> ConfigItem Disconnected {
	<span style="color:blue;">get</span> {
		<span style="color:blue;">if</span> (<span style="color:blue;">this</span>[<span style="color:maroon;">"Disconnected"</span>] == <span style="color:blue;">null</span>) {
			ConfigItem item = <span style="color:blue;">new</span> ConfigItem();
			item.IPAddress = <span style="color:maroon;">"127.0.0.1"</span>;
			item.Condition = ConditionKind.Equals;
			item.DisplayText = <span style="color:maroon;">"disconnected."</span>;
			item.Icon = IconKind.Disconnected;
			<span style="color:blue;">this</span>[<span style="color:maroon;">"Disconnected"</span>] = item;
		}
		<span style="color:blue;">return</span> (ConfigItem)<span style="color:blue;">this</span>[<span style="color:maroon;">"Disconnected"</span>];
	}
	<span style="color:blue;">set</span> {
		<span style="color:blue;">this</span>[<span style="color:maroon;">"Disconnected"</span>] = value;
	}
}</pre><p>I found that a suitable default value was needed to start off with in<br /> settings, so I did something similar for a Home, Work, Unknown, and Other<br /> network. This way I can persist the Settings using the Settings API instead of<br /> something home cooked (although I'm not sure if you would have to to avoid<br /> version conflicts...) UserScopedSettings look to me a lot like IsolatedStorage,<br /> that is the version and the product name help determine where settings should<br /> go. If you wanted to use the same settings across different versions, I guess<br /> you would have to copy the user.config file from one version location to the<br /> next.</p><p>Next I wanted to see what the designer had to offer. The table layout panel<br /> was real nice. It took care of all of my layout issues with respect to space. To<br /> get what I wanted done, I first created a dummy Collection that inherits from<br /> System.ComponentModel.BindingList&lt;&gt;:</p><pre><span style="color:blue;">internal</span> <span style="color:blue;">class</span> ConfigItemList : BindingList&lt;ConfigItem&gt; {}</pre><p>This is how I was able to add it as an Object datasource to the Data Sources<br /> window:</p><p><a href="http://chrispelatari.files.wordpress.com/2005/12/datawindow_tablelayoutpanel.png"><img class="alignnone size-full wp-image-1167" alt="DataWindow_TableLayoutPanel" src="http://chrispelatari.files.wordpress.com/2005/12/datawindow_tablelayoutpanel.png" width="377" height="324" /></a></p><p>From there, you can change the type of control you would like to output. I<br /> simply Dock.Fill 'ed the TableLayoutPanel and added the correct amount of rows.<br /> To get the labels to line up with the controls, I set all of their AnchorStyles<br /> to Top | Left (that's Top AND Left). When each usercontrol is loaded up, I<br /> manually bind to the information. When the Save button is clicked, all of the<br /> info gets put back into the Settings object from the controls and<br /> Settings.Default.Save() is called. This automatically saves the changed data to<br /> a safe location under Documents And Settings (specifically Local<br /> SettingsApplication DataCompanyNameFileName+ a bunch of other<br /> stuffProductVersion).</p><p>Now, for the main reason I created this thing: I host a few external<br /> sites at work, and I can't see them without an entry in my hosts file<br /> (%windir%system32driversetchosts) for each one. At home (or anywhere else)<br /> however, I need to be able to rely on DNS to be able to get me to those sites,<br /> so I created 2 extra hosts files, hosts.work and hosts.home. hosts.home pretty<br /> much just has the single entry:</p><p>127.0.0.1    localhost</p><p>whereas hosts.work contains definitions to the internal network address of<br /> the servers involved. I created 2 batch files that copy over the hosts file<br /> depending on where I am. The one to switch to work has the following<br /> command:</p><p>copy /Y %windir%system32driversetchosts.work<br /> %windir%system32driversetchosts</p><p>and the one for home simply replaces hosts.home into the hosts file the same<br /> way. So the command to execute for work is the fully qualified path to the bat<br /> file. Everything else has the fully qualified path to the switch to home batch<br /> script. So now, I just have this small utility run on startup and stay in the<br /> tray, and whenever the network is changed, I am automatically configured to go<br /> with this utility.</p><p class="media">[ Currently Playing : Quarantined - At the Drive-In -<br /> Relationship of Command (5:24) ]</p>
